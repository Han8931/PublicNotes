### 2's Complement
2's complement  = 1's complement +1

12  : 0000 1100
-12 : 1111 0100
= -128+64+32+16 + 8

12-12 = 100000000
Overflow, so it is 0

- 0: 0000
- 1: 0001
- 2: 0010
- 3: 0011
- 7: 0111
- -8: 1000
- -7: 1001
- -1: 1111

```python
print(~12)
>> -13
```

  12: 0000 1100
~12: 1111 0011 = -13
= -128+64+32+16 + 3 = -13

```python
print(12&13)
>> 12
```

12      : 0000 1100
13      : 0000 1101 
12&13: 0000 1100

```python
print(12|13)
>> 13
```

12      : 0000 1100
13      : 0000 1101 
12|13 : 0000 1101

```python
print(25|30)
>> 31
```

25      : 0001 1001
30      : 0001 1110 
25|30 : 0001 1111

```python
print(12^1)
>> 13
```

12      : 0000 1100
1        : 0000 0001 
12^1   : 0000 1101

```python
print(12^13)
>> 1
```

12      : 0000 1100
13      : 0000 1101 
12^13 : 0000 0001

```python
print(10<<2)
>> 40
```

10             : 0000 1010
10<<2      : 0010 1000

### Python's Bitwise Operation
```python
print(f"bin(0b0101^~0b1100): {bin(0b0101^~0b1100)}") 
>> '-0b1010'
```
We got -10, but we expected...

1100
~1100=0011

0101
0011
0110, which is 6. What happened?

1100=12      
~12 = -13 = 1111 0011

0000 0101
1111 0011
1111 0110 = -10

#### Bit Masking
```python
MASK = 0b1111 # Create a mask with maximum value in a given bit limit. 
print(f"bin(0b0101^(0b1100^MASK)): {bin(0b0101^(0b1100^MASK))}") 
>> '0b110'
```
1100^1111 = 0011
0101^0011 = 0110(=6), which is expected
